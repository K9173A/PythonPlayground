"""
Сложность:
1. Худший случай: O(n^2).
2. Лучший случай: O(n * log n).
3. Средний случай: O(n * log n).
Операция разделения массива на две части относительно опорного элемента занимает
время O(log n). Поскольку все операции разделения, проделываемые на одной глубине
рекурсии, обрабатывают разные части исходного массива, размер которого постоянен,
суммарно на каждом уровне рекурсии потребуется также O(n) операций. Следовательно,
общая сложность алгоритма определяется лишь количеством разделений, то есть
глубиной рекурсии. Глубина рекурсии, в свою очередь, зависит от сочетания входных
данных и способа определения опорного элемента.
"""


def quick_sort(seq):
    """
    Реализация быстрой сортировки. Рекурсивный вариант.
    :param seq: любая изменяемая коллекция с гетерогенными элементами,
    которые можно сравнивать.
    :return: коллекция с элементами, расположенными по возрастанию.
    Examples:
    >>> quick_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]
    >>> quick_sort([])
    []
    >>> quick_sort([-2, -5, -45])
    [-45, -5, -2]
    """
    length = len(seq)
    if length <= 1:
        return seq
    else:
        # В качестве pivot используется последний элемент.
        pivot = seq.pop()
        # lesser - часть коллекции, которая меньше pivot, будет тут.
        # greater -  части коллекции, которая меньше pivot, будет тут.
        greater, lesser = [], []
        for element in seq:
            if element > pivot:
                greater.append(element)
            else:
                lesser.append(element)
        # Рекурсивно вызывается функция сортировки отдельно для
        # greater и lesser. В конце все части объединяются в единую
        # коллекцию. Между ними вставляется pivot.
        return quick_sort(lesser) + [pivot] + quick_sort(greater)


if __name__ == "__main__":
    user_input = input("Enter numbers separated by a comma:\n").strip()
    unsorted = [int(item) for item in user_input.split(",")]
    print(quick_sort(unsorted))
