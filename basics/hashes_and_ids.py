# Есть три концепции, которые нужно понимать в оношении к `id`, `hash`, `==` и `is`.
# 1. Идентичность
# 2. Значение
# 3. Значение хэша
# И не все объекты имеют все три.
# 1. Все объекты имеют идентичность. Функция `id` возвращает число, соответствующее
# идентичности объекта (в cpython возвращает адрес объекта в памяти, а другие интерпретаторы
# могут возвращать что-то другое. Если два объекта, которые существуют в одно и то же время имеют
# одну идентичность, это две ссылки на один и тот же объект. Оператор `is` сравнивает элементы
# по их идентичности. `a is b` эквивалентно `id(a) == id(b)`.
a = 5
b = 5
print(a is b)  # True
print(id(a) == id(b))  # True

# 2. Все объекты имеют значение. Некоторые объекты могут не иметь определённого значение, кроме
# своей идентичности (поэтому значение и идентичность могут быть синонимами в некоторых случаях).
# Значение можно определить как что-то, что можно сравнить оператором `==`, поэтому всякий раз,
# когда получаем `a == b`, можно сказать, что `a` и `b` имеют одно и то же значение.
# Объекты-контейнеры (как `list`) имеют значение, которое определяется их содержимым, а другие
# виды объектов могут иметь значения на базе своих атрибутов. Объекты разных типов могут иногда
# иметь одинаковые значения `0 == 0.0 == 0j == False` (`bool` является числом в Python, по
# историческим причинам).
print(0 == 0.0)  # True
# Если класс не определяет метод `__eq__` (чтобы реализовать оператор `==`), он унаследует
# дефолтную версию от `object` и инстансы этого класса будут сравниваться лишь по из идентичности.
# Это подходящий способ, когда в инстансы имеют большие семантические отличия. Например, два
# разных сокета, законнекченных в один порт и на одном хосте должны восприниматься по-разному,
# так как один получает HTML страницу, а другой картинку, поэтому они не будут иметь одно значение.

# 3. Некоторые объекты имеют hash-значение, что означает, что они могут быть использованы в
# `dict` в качестве ключей (и храниться в `set`). Функция `hash(a)` возвращает хэш объекта `a`:
# числовое значение, основанное на значении объекта Хэш объекта ОБЯЗАН оставаться неизменным на
# всём протяжении существования объекта. Поэтому хэши имеет смысл использовать только для объектов
# с неизменяемых значением. Несколько разных объектов могут иметь один и тот же хэш, однако хорошо
# спроектированные хэш-функции будут избегать это по возможности. Хранение объектов с одним хэшом
# в `dict` менее эффективно, чем хранение объектов с разными хэшами (каждая коллизия хэша требует
# больше работы). Объекты хэшируемы по дефолту (так как их дефолтное значение - это их
# идентичность, которое является неизмененямых). Если написать кастомную реализацию `__eq__` в
# кастомном классе, дефолтная реализация хэша будет отключена, так как вы определили новое
# "значение" для инстансов. Вы должны будете написать `__hash__` метод тоже, если вы хотите, чтобы
# ваш класс был хэшируемым. Если вы наследуетесь от хэшируемого класс, но не хотете, чтобы ваш
# класс был хэшируемым, то можно установить `__hash__ = None` в теле класса.


class Foo:
    def __init__(self, name):
        self.name = name

    def __eq__(self, other):
        return self.name == other.name

